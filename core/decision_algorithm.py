"""
Dynamic Decision Algorithm - Human-like decision making for strategic interventions
based on event scoring, confidence thresholds, and contextual signals.
"""

import asyncio
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Tuple
from dataclasses import dataclass
from termcolor import colored

from core.workspace_graph import WorkspaceGraph


@dataclass
class EventScore:
    """Represents the score for a single event."""
    event_type: str
    base_score: int
    multipliers: List[Tuple[str, float]]
    final_score: int
    reasoning: str


@dataclass
class DecisionContext:
    """Context information for making intervention decisions."""
    total_score: int
    threshold: int
    confidence: float
    recent_events: List[Dict[str, Any]]
    graph_signals: List[str]
    contextual_boosts: List[str]
    should_intervene: bool
    reasoning: str


class DecisionAlgorithm:
    """
    Dynamic decision algorithm that mimics human navigation behavior:
    1. Accumulates change events in a rolling buffer
    2. Scores events for relevance using pattern matching
    3. Evaluates cumulative score against adjustable threshold
    4. Cross-checks against goal and graph for big-picture divergence
    5. Boosts confidence with contextual signals
    6. Intervenes only if final confidence exceeds threshold
    """
    
    def __init__(self):
        # Core algorithm parameters
        self.buffer_size = 15  # Rolling window of recent events
        self.base_threshold = 2  # Default intervention threshold (very sensitive for testing)
        self.confidence_threshold = 30.0  # Minimum confidence to intervene (very low barrier for testing)
        self.debug_mode = True  # Enhanced debugging
        
        # Current state
        self.event_buffer: List[Dict[str, Any]] = []
        self.current_score = 0
        self.last_intervention: Optional[datetime] = None
        self.last_intervention_time: Optional[datetime] = None
        self.quiet_mode = False
        
        # Adaptive parameters (adjusted based on feedback)
        self.threshold_adjustment = 0
        self.confidence_adjustment = 0.0
        self.pattern_weights = {
            'structural_change': 3,      # Increased importance
            'complexity_increase': 2,    # Increased importance  
            'goal_relevance': 4,         # Increased importance
            'external_reference': 2,
            'pattern_violation': 3,      # Increased importance
            'rapid_changes': 2,          # Increased importance
            'code_quality_concern': 3,   # New pattern
            'architectural_drift': 4,    # New pattern
            'strategic_moment': 3        # New pattern
        }
        
        # Strategic thinking state
        self.change_momentum = 0         # Tracks pace of development
        self.complexity_accumulator = 0  # Tracks growing complexity
        self.last_strategic_intervention = None
        self.strategic_pause_threshold = 120  # Minimum seconds between strategic suggestions
        
        # Learning from feedback
        self.positive_feedback_count = 0
        self.negative_feedback_count = 0
        self.recent_decisions: List[Dict[str, Any]] = []
    
    async def process_event(self, 
                           event_data: Dict[str, Any], 
                           current_goal: Optional[str],
                           workspace_graph: WorkspaceGraph) -> Tuple[bool, float, Optional[str]]:
        """
        Process a new event and determine if intervention is needed.
        
        Returns:
            (should_intervene, confidence, suggestion)
        """
        # Add event to buffer
        self._add_to_buffer(event_data)
        
        # Score the event
        event_score = await self._score_event(event_data, current_goal, workspace_graph)
        
        # Update cumulative score
        self._update_cumulative_score()
        
        # Make decision
        decision_context = await self._make_decision(current_goal, workspace_graph)
        
        # Suggestions are now generated by NavigatorAgent in main.py
        suggestion = None
        
        # Record decision for learning
        self._record_decision(decision_context, decision_context.should_intervene)
        
        # Prepare detailed decision information for stream display
        decision_details = {
            'should_intervene': decision_context.should_intervene and not self.quiet_mode,
            'confidence': decision_context.confidence,
            'total_score': decision_context.total_score,
            'threshold': decision_context.threshold,
            'reasoning': decision_context.reasoning,
            'event_score': event_score,
            'graph_signals': decision_context.graph_signals,
            'contextual_boosts': decision_context.contextual_boosts,
            'quiet_mode': self.quiet_mode
        }
        
        if self.quiet_mode:
            return False, decision_context.confidence, None
        
        return decision_context.should_intervene, decision_context.confidence, suggestion
    
    async def process_event_with_details(self, 
                                       event_data: Dict[str, Any], 
                                       current_goal: Optional[str],
                                       workspace_graph: WorkspaceGraph) -> Dict[str, Any]:
        """
        Process event and return detailed decision information for stream display.
        
        Returns:
            Dictionary with decision details including reasoning, scores, and factors
        """
        # Add event to buffer
        self._add_to_buffer(event_data)
        
        # Score the event
        event_score = await self._score_event(event_data, current_goal, workspace_graph)
        
        # Update cumulative score
        self._update_cumulative_score()
        
        # Make decision
        decision_context = await self._make_decision(current_goal, workspace_graph)
        
        # Note: Suggestions are now generated by the NavigatorAgent, not here
        suggestion = None
        
        # Record decision for learning
        self._record_decision(decision_context, decision_context.should_intervene)
        
        # Return comprehensive decision details
        return {
            'should_intervene': decision_context.should_intervene and not self.quiet_mode,
            'confidence': decision_context.confidence,
            'total_score': decision_context.total_score,
            'threshold': decision_context.threshold,
            'reasoning': decision_context.reasoning,
            'event_score': {
                'event_type': event_score.event_type,
                'base_score': event_score.base_score,
                'final_score': event_score.final_score,
                'multipliers': event_score.multipliers,
                'reasoning': event_score.reasoning
            },
            'graph_signals': decision_context.graph_signals,
            'contextual_boosts': decision_context.contextual_boosts,
            'quiet_mode': self.quiet_mode,
            'suggestion': suggestion,
            'decision_factors': {
                'score_vs_threshold': f"{decision_context.total_score}/{decision_context.threshold}",
                'recent_events_count': len(self.event_buffer),
                'time_since_last_intervention': self._time_since_last_intervention()
            }
        }
    
    def _time_since_last_intervention(self) -> str:
        """Calculate time since last intervention for decision factors."""
        if not hasattr(self, 'last_intervention_time') or not self.last_intervention_time:
            return "never"
        
        time_diff = datetime.now() - self.last_intervention_time
        if time_diff.total_seconds() < 60:
            return f"{int(time_diff.total_seconds())}s"
        elif time_diff.total_seconds() < 3600:
            return f"{int(time_diff.total_seconds() / 60)}m"
        else:
            return f"{int(time_diff.total_seconds() / 3600)}h"
    
    async def _score_event(self, 
                          event_data: Dict[str, Any], 
                          current_goal: Optional[str],
                          workspace_graph: WorkspaceGraph) -> EventScore:
        """Score an individual event for relevance and importance."""
        event_type = event_data.get('type', 'unknown')
        base_score = 0
        multipliers = []
        reasoning_parts = []
        
        # Base scoring by event type (more generous scoring)
        if event_type == 'modified':
            base_score = 2  # Increased from 1
            reasoning_parts.append("file modification")
        elif event_type == 'created':
            base_score = 3  # Increased from 2
            reasoning_parts.append("new file created")
        elif event_type == 'deleted':
            base_score = 3  # Increased from 2
            reasoning_parts.append("file deleted")
        elif event_type == 'moved':
            base_score = 2  # Increased from 1
            reasoning_parts.append("file moved/renamed")
        elif event_type == 'remote_change':
            base_score = 3  # Increased from 2
            reasoning_parts.append("remote resource updated")
        
        # Pattern-based multipliers
        if 'batch_info' in event_data:
            batch_info = event_data['batch_info']
            
            # Structural changes
            if batch_info.get('event_types', {}).get('created', 0) > 0:
                multipliers.append(('structural_change', 1.5))
                reasoning_parts.append("structural changes detected")
            
            # Multiple files affected
            affected_count = len(batch_info.get('affected_files', []))
            if affected_count > 2:
                multipliers.append(('multiple_files', 1.2 + (affected_count * 0.1)))
                reasoning_parts.append(f"{affected_count} files affected")
            
            # High significance score from observer
            significance = batch_info.get('significance_score', 0)
            if significance > 5:
                multipliers.append(('high_significance', 1.3))
                reasoning_parts.append("high significance score")
        
        # Goal relevance analysis
        if current_goal and await self._is_goal_relevant(event_data, current_goal, workspace_graph):
            multipliers.append(('goal_relevance', 2.0))
            reasoning_parts.append("relevant to current goal")
        
        # Graph context analysis
        graph_multiplier = await self._analyze_graph_context(event_data, workspace_graph)
        if graph_multiplier > 1.0:
            multipliers.append(('graph_context', graph_multiplier))
            reasoning_parts.append("significant graph context")
        
        # Calculate final score
        final_score = base_score
        for _, multiplier in multipliers:
            final_score = int(final_score * multiplier)
        
        final_score = min(final_score, 10)  # Cap at 10
        
        return EventScore(
            event_type=event_type,
            base_score=base_score,
            multipliers=multipliers,
            final_score=final_score,
            reasoning=" + ".join(reasoning_parts)
        )
    
    async def _is_goal_relevant(self, 
                               event_data: Dict[str, Any], 
                               goal: str, 
                               workspace_graph: WorkspaceGraph) -> bool:
        """Check if an event is relevant to the current goal."""
        # Simple keyword matching for now
        goal_keywords = goal.lower().split()
        
        # Check file paths
        if 'src_path' in event_data:
            file_path = event_data['src_path'].lower()
            if any(keyword in file_path for keyword in goal_keywords):
                return True
        
        # Check if files are connected to goal in graph
        if 'batch_info' in event_data:
            for file_path in event_data['batch_info'].get('affected_files', []):
                file_node = f"file:{file_path}"
                if file_node in workspace_graph.nodes:
                    # Check if this file is connected to any goal
                    related_nodes = await workspace_graph.find_related_nodes(file_node, max_depth=2)
                    for node in related_nodes:
                        if node.get('type') == 'goal' and goal.lower() in node.get('content', '').lower():
                            return True
        
        return False
    
    async def _analyze_graph_context(self, 
                                    event_data: Dict[str, Any], 
                                    workspace_graph: WorkspaceGraph) -> float:
        """Analyze graph context to determine event importance multiplier."""
        multiplier = 1.0
        
        # Check for high-coupling files being modified
        if 'batch_info' in event_data:
            for file_path in event_data['batch_info'].get('affected_files', []):
                file_node = f"file:{file_path}"
                if file_node in workspace_graph.graph:
                    degree = workspace_graph.graph.degree(file_node)
                    if degree > 8:  # High coupling threshold
                        multiplier = max(multiplier, 1.4)
        
        # Check for external reference connections
        patterns = await workspace_graph.detect_patterns()
        for pattern in patterns:
            if pattern.get('concern_level') in ['high', 'medium']:
                multiplier = max(multiplier, 1.2)
        
        return multiplier
    
    def _add_to_buffer(self, event_data: Dict[str, Any]):
        """Add event to the rolling buffer."""
        self.event_buffer.append({
            **event_data,
            'added_at': datetime.now().isoformat()
        })
        
        # Maintain buffer size
        if len(self.event_buffer) > self.buffer_size:
            self.event_buffer.pop(0)
    
    def _update_cumulative_score(self):
        """Update the cumulative score from all events in buffer."""
        # Simple sum for now - could be more sophisticated
        # (e.g., time decay, pattern recognition)
        self.current_score = len(self.event_buffer)
        
        # Add bonus for recent rapid changes
        now = datetime.now()
        recent_events = [
            event for event in self.event_buffer
            if (now - datetime.fromisoformat(event['added_at'])).total_seconds() < 60
        ]
        
        if len(recent_events) > 3:
            self.current_score += 2  # Rapid change bonus
    
    async def _make_decision(self, 
                            current_goal: Optional[str],
                            workspace_graph: WorkspaceGraph) -> DecisionContext:
        """Make strategic intervention decisions like a human navigator."""
        
        # Update strategic thinking state
        self._update_strategic_state()
        
        # Calculate adjusted threshold
        effective_threshold = self.base_threshold + self.threshold_adjustment
        if self.quiet_mode:
            effective_threshold += 3  # Higher threshold in quiet mode
        
        # Strategic intervention detection
        strategic_signals = await self._detect_strategic_moments(current_goal, workspace_graph)
        
        # Base confidence from accumulated evidence
        score_ratio = self.current_score / max(effective_threshold, 1)
        base_confidence = min(score_ratio * 60, 85)  # Scale to 0-85
        
        # Strategic confidence boosts
        contextual_boosts = []
        confidence_boost = 0
        
        # Strategic moment detection
        if strategic_signals['strategic_moment']:
            confidence_boost += 20
            contextual_boosts.append("strategic moment detected")
        
        # Goal alignment and progress
        if current_goal:
            confidence_boost += 10
            contextual_boosts.append("goal is set")
            
            if strategic_signals['goal_drift']:
                confidence_boost += 15
                contextual_boosts.append("potential goal drift")
        
        # Code quality concerns accumulating
        if strategic_signals['quality_concern']:
            confidence_boost += 12
            contextual_boosts.append("code quality patterns emerging")
        
        # Architectural momentum
        if strategic_signals['architectural_shift']:
            confidence_boost += 18
            contextual_boosts.append("architectural changes detected")
        
        # Change momentum analysis
        if self.change_momentum > 8:  # High activity period
            confidence_boost += 8
            contextual_boosts.append("high development momentum")
        elif self.change_momentum < 3:  # Low activity - good time for strategic input
            confidence_boost += 5
            contextual_boosts.append("natural pause for reflection")
        
        # Strategic timing (not too frequent, not too rare)
        time_since_last = self._time_since_last_strategic_intervention()
        if 60 < time_since_last < 600:  # Sweet spot: 1-10 minutes
            confidence_boost += 8
            contextual_boosts.append("good strategic timing")
        elif time_since_last > 900:  # Very long time - should engage
            confidence_boost += 15
            contextual_boosts.append("overdue for strategic input")
        
        # Apply feedback-based adjustments
        final_confidence = base_confidence + confidence_boost + self.confidence_adjustment
        final_confidence = max(0, min(100, final_confidence))  # Clamp to 0-100
        
        # Human-like intervention decision
        should_intervene = (
            (self.current_score >= effective_threshold or strategic_signals['urgent']) and
            final_confidence >= self.confidence_threshold and
            time_since_last > 30  # Minimum 30 seconds between interventions
        )
        
        # Debug output
        if self.debug_mode:
            print(colored(f"🤔 [DECISION] Score: {self.current_score}/{effective_threshold}, " +
                         f"Confidence: {final_confidence:.1f}%/{self.confidence_threshold}, " +
                         f"Time since last: {time_since_last:.1f}s", "magenta"))
            print(colored(f"🎯 [DECISION] Should intervene: {should_intervene}", 
                         "green" if should_intervene else "yellow"))
        
        # Update intervention timing
        if should_intervene:
            self.last_strategic_intervention = datetime.now()
        
        # Build comprehensive reasoning
        reasoning = f"Score {self.current_score}/{effective_threshold}, confidence {final_confidence:.1f}%"
        if strategic_signals['primary_trigger']:
            reasoning += f", triggered by: {strategic_signals['primary_trigger']}"
        if contextual_boosts:
            reasoning += f", factors: {', '.join(contextual_boosts[:3])}"  # Limit to avoid clutter
        
        # Get graph patterns for context
        try:
            patterns = await workspace_graph.detect_patterns()
            graph_signals = [p.get('description', 'pattern detected') for p in patterns[:2]]
        except:
            graph_signals = []
        
        return DecisionContext(
            total_score=self.current_score,
            threshold=effective_threshold,
            confidence=final_confidence,
            recent_events=self.event_buffer[-5:],  # Last 5 events
            graph_signals=graph_signals,  # Top 2 patterns
            contextual_boosts=contextual_boosts,
            should_intervene=should_intervene,
            reasoning=reasoning
        )
    
    async def _generate_intervention_suggestion(self,
                                               context: DecisionContext,
                                               goal: Optional[str],
                                               workspace_graph: WorkspaceGraph) -> str:
        """Generate a strategic intervention suggestion using Navigator agent."""
        
        try:
            # Import Navigator here to avoid circular dependency
            from agents.navigator import NavigatorAgent
            
            # Create event context for Navigator
            event_context = {
                'decision_context': {
                    'total_score': context.total_score,
                    'threshold': context.threshold,
                    'confidence': context.confidence,
                    'reasoning': context.reasoning,
                    'contextual_boosts': context.contextual_boosts
                },
                'recent_events': context.recent_events,
                'graph_signals': context.graph_signals,
                'strategic_trigger': context.reasoning
            }
            
            # Note: In the actual implementation, we would need access to the Navigator instance
            # For now, generate strategic suggestions based on the decision context
            
            # Determine the type of strategic intervention needed
            if "architectural changes" in context.reasoning:
                return f"On your {goal or 'development'}: Architecture shifts detected across {len(context.recent_events)} files. Big pic: Consider consolidating these changes into a coherent design pattern? Preview idea: Review component relationships. Your thoughts?"
            
            elif "goal drift" in context.reasoning:
                return f"On your {goal or 'current task'}: Recent changes seem to diverge from stated goal. Big pic: Are we still aligned with the original intent, or has the scope evolved? Preview idea: Quick goal review session."
            
            elif "critical file changes" in context.reasoning:
                return f"On your {goal or 'development'}: Core system files being modified—observing potential ripple effects. Big pic: Consider impact on dependent components? Preview idea: Trace downstream effects."
            
            elif "high development pace" in context.reasoning:
                return f"On your {goal or 'current work'}: High momentum detected—good progress! Big pic: Natural pause point for quality check? Preview idea: Quick architecture health review."
            
            elif "complexity accumulation" in context.reasoning:
                return f"On your {goal or 'implementation'}: Growing complexity patterns emerging. Big pic: Consider refactoring opportunities before it becomes technical debt? Preview idea: Identify simplification points."
            
            elif context.graph_signals:
                primary_concern = context.graph_signals[0]
                return f"On your {goal or 'current work'}: Graph analysis flags '{primary_concern}'. Big pic: Strategic concern worth addressing? Preview idea: {self._suggest_strategic_action(primary_concern)}."
            
            elif len(context.recent_events) > 4:
                return f"On your {goal or 'development'}: Multiple changes accumulating—good active development. Big pic: Consider consolidation checkpoint? Preview idea: Review change coherence."
            
            else:
                return f"On your {goal or 'current work'}: Strategic checkpoint triggered. Big pic: How are we tracking against larger objectives? Your thoughts?"
                
        except Exception as e:
            # Fallback to simple strategic suggestion
            return f"On your {goal or 'current work'}: Strategic moment detected. Worth pausing to assess bigger picture? Your thoughts?"
    
    def _suggest_strategic_action(self, concern: str) -> str:
        """Suggest specific strategic actions based on concerns."""
        if "coupling" in concern.lower():
            return "Review module dependencies"
        elif "complexity" in concern.lower():
            return "Consider breaking down complex components"
        elif "pattern" in concern.lower():
            return "Align with established patterns"
        else:
            return "Review architectural coherence"
    
    def _too_soon_since_last_intervention(self) -> bool:
        """Check if it's too soon since the last intervention."""
        if not self.last_intervention:
            return False
        
        time_since = (datetime.now() - self.last_intervention).total_seconds()
        min_interval = 120 if not self.quiet_mode else 300  # 2-5 minutes
        
        return time_since < min_interval
    
    def _record_decision(self, context: DecisionContext, intervened: bool):
        """Record a decision for learning purposes."""
        decision_record = {
            'timestamp': datetime.now().isoformat(),
            'score': context.total_score,
            'threshold': context.threshold,
            'confidence': context.confidence,
            'intervened': intervened,
            'reasoning': context.reasoning
        }
        
        self.recent_decisions.append(decision_record)
        
        # Keep recent decisions manageable
        if len(self.recent_decisions) > 50:
            self.recent_decisions = self.recent_decisions[-25:]
        
        if intervened:
            self.last_intervention = datetime.now()
    
    async def adjust_from_feedback(self, positive: bool):
        """Adjust algorithm parameters based on user feedback."""
        if positive:
            self.positive_feedback_count += 1
            # Slightly lower threshold to be more proactive
            if self.positive_feedback_count % 3 == 0:
                self.threshold_adjustment = max(self.threshold_adjustment - 1, -3)
        else:
            self.negative_feedback_count += 1
            # Raise threshold to be less intrusive
            if self.negative_feedback_count % 2 == 0:
                self.threshold_adjustment = min(self.threshold_adjustment + 1, 5)
        
        # Adjust confidence threshold based on feedback ratio
        total_feedback = self.positive_feedback_count + self.negative_feedback_count
        if total_feedback >= 5:
            positive_ratio = self.positive_feedback_count / total_feedback
            if positive_ratio > 0.7:
                # Mostly positive - be slightly more aggressive
                self.confidence_adjustment = min(self.confidence_adjustment + 2, 10)
            elif positive_ratio < 0.3:
                # Mostly negative - be more conservative
                self.confidence_adjustment = max(self.confidence_adjustment - 3, -15)
    
    def set_quiet_mode(self, enabled: bool):
        """Enable or disable quiet mode."""
        self.quiet_mode = enabled
    
    def reset_for_new_goal(self):
        """Reset algorithm state for a new goal."""
        self.event_buffer.clear()
        self.current_score = 0
        # Keep learning adjustments but reset intervention timing
        self.last_intervention = None
    
    def get_current_score(self) -> int:
        """Get the current cumulative score."""
        return self.current_score
    
    def get_debug_info(self) -> Dict[str, Any]:
        """Get detailed debug information about the algorithm state."""
        return {
            'buffer_size': len(self.event_buffer),
            'current_score': self.current_score,
            'base_threshold': self.base_threshold,
            'threshold_adjustment': self.threshold_adjustment,
            'confidence_adjustment': self.confidence_adjustment,
            'quiet_mode': self.quiet_mode,
            'feedback_stats': {
                'positive': self.positive_feedback_count,
                'negative': self.negative_feedback_count,
                'ratio': self.positive_feedback_count / max(self.positive_feedback_count + self.negative_feedback_count, 1)
            },
            'last_intervention': self.last_intervention.isoformat() if self.last_intervention else None,
            'recent_decisions': self.recent_decisions[-5:]
        }
    
    def _update_strategic_state(self):
        """Update strategic thinking state based on recent activity."""
        # Calculate change momentum (events per minute)
        recent_events = [e for e in self.event_buffer if 
                        (datetime.now() - datetime.fromisoformat(e['added_at'])).total_seconds() < 60]
        self.change_momentum = len(recent_events)
        
        # Update complexity accumulator
        structural_events = [e for e in recent_events if e.get('type') in ['created', 'deleted', 'moved']]
        self.complexity_accumulator += len(structural_events)
        
        # Decay complexity over time
        if not hasattr(self, '_last_complexity_update'):
            self._last_complexity_update = datetime.now()
        
        time_since_update = (datetime.now() - self._last_complexity_update).total_seconds()
        if time_since_update > 300:  # 5 minutes
            self.complexity_accumulator = max(0, self.complexity_accumulator - 1)
            self._last_complexity_update = datetime.now()
    
    async def _detect_strategic_moments(self, current_goal: Optional[str], workspace_graph: WorkspaceGraph) -> Dict[str, Any]:
        """Detect strategic moments that warrant navigator intervention."""
        signals = {
            'strategic_moment': False,
            'goal_drift': False,
            'quality_concern': False,
            'architectural_shift': False,
            'urgent': False,
            'primary_trigger': None
        }
        
        try:
            # Detect architectural changes
            structural_changes = sum(1 for e in self.event_buffer if e.get('type') in ['created', 'deleted'])
            if structural_changes >= 2:
                signals['architectural_shift'] = True
                signals['strategic_moment'] = True
                signals['primary_trigger'] = "architectural changes"
            
            # Detect potential goal drift
            if current_goal and len(self.event_buffer) >= 3:
                # Simple heuristic: if many files changed but none seem goal-related
                goal_keywords = set(current_goal.lower().split())
                goal_related_changes = 0
                
                for event in self.event_buffer[-5:]:
                    file_path = event.get('src_path', '').lower()
                    if any(keyword in file_path for keyword in goal_keywords):
                        goal_related_changes += 1
                
                if goal_related_changes == 0 and len(self.event_buffer) >= 3:
                    signals['goal_drift'] = True
                    signals['strategic_moment'] = True
                    if not signals['primary_trigger']:
                        signals['primary_trigger'] = "potential goal drift"
            
            # Detect quality concerns
            if self.complexity_accumulator > 5:
                signals['quality_concern'] = True
                signals['strategic_moment'] = True
                if not signals['primary_trigger']:
                    signals['primary_trigger'] = "complexity accumulation"
            
            # Detect rapid development that might need strategic pause
            if self.change_momentum > 10:
                signals['strategic_moment'] = True
                if not signals['primary_trigger']:
                    signals['primary_trigger'] = "high development pace"
            
            # Detect urgent situations
            critical_files = ['main.py', 'app.py', '__init__.py', 'settings.py', 'config.py']
            for event in self.event_buffer[-3:]:
                file_name = event.get('src_path', '').split('/')[-1].lower()
                if any(critical in file_name for critical in critical_files):
                    signals['urgent'] = True
                    signals['strategic_moment'] = True
                    if not signals['primary_trigger']:
                        signals['primary_trigger'] = "critical file changes"
            
            # Graph pattern analysis
            patterns = await workspace_graph.detect_patterns()
            high_concern_patterns = [p for p in patterns if p.get('concern_level') == 'high']
            if high_concern_patterns:
                signals['strategic_moment'] = True
                if not signals['primary_trigger']:
                    signals['primary_trigger'] = "graph concerns detected"
            
        except Exception as e:
            # Fallback to basic scoring if analysis fails
            if self.current_score > self.base_threshold * 1.5:
                signals['strategic_moment'] = True
                signals['primary_trigger'] = "high activity score"
        
        return signals
    
    def _time_since_last_strategic_intervention(self) -> float:
        """Get time in seconds since last strategic intervention."""
        if not self.last_strategic_intervention:
            return 999999  # Very large number if never intervened
        
        return (datetime.now() - self.last_strategic_intervention).total_seconds()